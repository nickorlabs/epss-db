# EPSS-DB Exploit Integration Plan

This document outlines a plan to integrate multiple exploit and vulnerability intelligence sources into EPSS-DB, addressing [Issue #16: Link with PoC information](https://github.com/hogehuga/epss-db/issues/16).

## Overview

The goal is to enhance EPSS-DB with concrete exploit information from multiple sources, enabling users to:
- Identify which CVEs have known public exploits
- Access exploit code, techniques, and references
- Correlate exploit availability with EPSS scores
- Make more informed vulnerability prioritization decisions

## Implementation Phases

### Phase 1: Core High-Value Sources

Based on EPSS variable importance modeling, these sources have the highest impact on exploit prediction:

1. **Metasploit Framework** (`source_msf`)
   - Source: Rapid7 GitHub repository or API
   - Data: Module metadata, CVE mappings, techniques
   - Implementation: Weekly update script

2. **ExploitDB** (`source_edb`)
   - Source: Offensive Security GitHub repository and searchsploit tool
   - Data: Exploits, CVE mappings, dates
   - Implementation: Weekly update script that uses searchsploit to query by CVE ID (e.g., `searchsploit --cve 2021-44228`) and updates the local database
   - Maintenance: Include periodic database updates (`searchsploit --update`)

3. **Nuclei Templates** (`source_nuclei`)
   - Source: ProjectDiscovery GitHub repository
   - Data: Vulnerability templates with CVE mappings
   - Implementation: Weekly update script

4. **GitHub Security Exploits** (`source_github`)
   - Source: GitHub API and PoC-in-GitHub API (https://poc-in-github.motikan2010.net/)
   - Data: Repositories containing exploit code by CVE
   - Implementation: Weekly update using the PoC-in-GitHub API (e.g., /api/v1/?cve_id=cve-2021-44228&sort=stargazers_count)
   - Benefit: Pre-indexed collection of exploit PoCs on GitHub with sorting by popularity
   
5. **CISA KEV Catalog** (`source_kev`, already implemented)
   - Continue using existing integration

### Phase 2: Secondary Sources

These sources provide additional context and coverage:

1. **GrayNoise Intelligence** (`source_graynoise`)
   - Source: GrayNoise Community API
   - Data: In-the-wild exploitation attempts
   - Implementation: Daily update script

2. **AttackerKB** (`source_attackerkb`)
   - Source: Rapid7 AttackerKB API
   - Data: Community vulnerability assessments
   - Implementation: Weekly update script

3. **Packet Storm** (`source_packetstorm`)
   - Source: Web scraping or downloadable archives
   - Data: Exploits, advisories, CVE mappings
   - Implementation: Weekly update script

4. **OSV (Open Source Vulnerabilities)** (`source_osv`)
   - Source: Google OSV API
   - Data: Open source package vulnerabilities
   - Implementation: Weekly update script

5. **Snyk Vulnerability Database** (`source_snyk`)
   - Source: Snyk API (free tier)
   - Data: Package vulnerabilities and exploitability
   - Implementation: Weekly update script

### Phase 3: Additional Enrichment

These sources add deeper context to vulnerabilities:

1. **Vendor-specific advisories** (`source_vendor_*`)
   - Sources: Microsoft (`source_vendor_ms`), Apache (`source_vendor_apache`), etc.
   - Data: Vendor-specific vulnerability details
   - Implementation: Monthly update scripts per vendor

2. **Technique classification** (`tag_technique_*`)
   - Source: Derived from exploit metadata
   - Data: Categorization (RCE, XSS, SQLi, etc.)
   - Implementation: Tagging script during import

3. **Domain indicators** (`source_domain_intel`)
   - Source: Threat intelligence feeds
   - Data: Domains associated with exploitation
   - Implementation: Weekly update script

## Database Schema

New tables to be created:

```sql
-- Main exploits table
CREATE TABLE IF NOT EXISTS exploits (
    id INT AUTO_INCREMENT PRIMARY KEY,
    cve_id VARCHAR(20) NOT NULL,
    source VARCHAR(50) NOT NULL,
    source_id VARCHAR(100) NOT NULL,
    url TEXT,
    title VARCHAR(255),
    description TEXT,
    date_published DATE,
    technique VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY unique_exploit (cve_id, source, source_id)
);

-- Exploit metadata (json-like structure)
CREATE TABLE IF NOT EXISTS exploit_metadata (
    exploit_id INT NOT NULL,
    meta_key VARCHAR(100) NOT NULL,
    meta_value TEXT,
    PRIMARY KEY (exploit_id, meta_key),
    FOREIGN KEY (exploit_id) REFERENCES exploits(id) ON DELETE CASCADE
);

-- Exploitation tags
CREATE TABLE IF NOT EXISTS exploit_tags (
    exploit_id INT NOT NULL,
    tag VARCHAR(100) NOT NULL,
    PRIMARY KEY (exploit_id, tag),
    FOREIGN KEY (exploit_id) REFERENCES exploits(id) ON DELETE CASCADE
);
```

## Implementation Architecture

1. **Main Script**: `update-exploits.sh`
   - Coordinates the update process for all exploit sources
   - Uses the same dynamic path detection pattern

2. **Source-specific Scripts**: `/subprogram/exploits/[source]-update.sh`
   - Each source has its own script for fetching and processing data
   - Converts source-specific format to common database schema

3. **Common Utilities**: `/subprogram/exploits/utils/`
   - Shared functions for database operations, data processing
   - Consistent error handling and logging

4. **Configuration**: `/conf/exploit-sources.conf`
   - Enable/disable specific sources
   - API keys and credentials (with secure handling)

## SQL Integration

Example SQL queries to integrate exploit data with EPSS:

```sql
-- Find high EPSS score CVEs with exploits
SELECT e.cve_id, e.score, e.percentile, COUNT(ex.id) as exploit_count 
FROM epss AS e
JOIN exploits AS ex ON e.cve_id = ex.cve_id
WHERE e.percentile > 0.9
GROUP BY e.cve_id, e.score, e.percentile
ORDER BY e.score DESC;

-- Find most recently exploited high-risk CVEs
SELECT e.cve_id, e.score, ex.source, ex.title, ex.date_published
FROM epss AS e
JOIN exploits AS ex ON e.cve_id = ex.cve_id
WHERE e.percentile > 0.75
ORDER BY ex.date_published DESC
LIMIT 20;
```

## UI Enhancements (Future)

Future versions could include:
- Web UI showing EPSS scores alongside exploit availability
- Ability to filter and sort by exploit existence
- Exploit detail pages with code snippets and references

## Testing Strategy

1. **Unit Tests**: Test each source-specific script independently
2. **Integration Tests**: Verify database schema and queries work correctly
3. **End-to-End Tests**: Full update process across all sources
