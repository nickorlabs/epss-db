#!/usr/bin/env python3
"""
ExploitDB Importer (Python)
- Downloads ExploitDB CSV
- Processes and sanitizes data
- Bulk imports into MySQL using LOAD DATA LOCAL INFILE
- Prints import summary
"""
import csv
import os
import sys
import tempfile
import urllib.request
import psycopg2
import psycopg2.extras

EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
EXPLOITDB_CSV_LOCAL = os.path.join(tempfile.gettempdir(), "files_exploits.csv")
EXPLOITS_CSV = os.path.join(tempfile.gettempdir(), "exploits.csv")

PG_CONFIG = {
    'host': os.environ.get('PGHOST', 'db'),
    'user': os.environ.get('PGUSER', 'postgres'),
    'password': os.environ.get('PGPASSWORD', 'postgres'),
    'dbname': os.environ.get('PGDATABASE', 'epssdb'),
}

def download_csv():
    print(f"Downloading ExploitDB CSV from {EXPLOITDB_CSV_URL} ...")
    urllib.request.urlretrieve(EXPLOITDB_CSV_URL, EXPLOITDB_CSV_LOCAL)
    print(f"Saved to {EXPLOITDB_CSV_LOCAL}")

def sanitize(text):
    if text is None:
        return ''
    return text.replace('\n', ' ').replace('\r', ' ').replace('"', '').replace("'", "''").replace('\\', '')

def process_exploits():
    print("Processing exploits and writing to CSV ...")
    with open(EXPLOITDB_CSV_LOCAL, newline='', encoding='utf-8') as infile, open(EXPLOITS_CSV, 'w', newline='', encoding='utf-8') as outfile:
        reader = csv.DictReader(infile)
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        total = 0
        for row in reader:
            id = row['id']
            description = row['description']
            cve_ids = set()
            if description:
                import re
                cve_ids = set(re.findall(r'CVE-[0-9]{4}-[0-9]{4,}', description))
            file = sanitize(row['file'])
            esc_title = sanitize(description)[:100]
            esc_description = sanitize(description)
            esc_type = sanitize(row['type'])
            url = f"https://www.exploit-db.com/exploits/{id}"
            date_published = row['date_published']
            if not cve_ids:
                cve_ids = {f'NOCVE-{id}'}
            for cve_id in cve_ids:
                writer.writerow([
                    cve_id, 'source_edb', id, url, esc_title, esc_description, date_published, esc_type
                ])
                total += 1
    print(f"Wrote {total} exploit rows to {EXPLOITS_CSV}")
    return total

def import_to_postgres():
    print("Importing exploits into PostgreSQL with COPY ...")
    conn = None
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        conn.autocommit = True
        cursor = conn.cursor()
        # Enable pgvector extension if not present
        try:
            cursor.execute("CREATE EXTENSION IF NOT EXISTS vector;")
        except Exception as e:
            print(f"Warning: Could not create pgvector extension: {e}")
        # Create exploits table if not exists (basic columns, adjust as needed)
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS exploits (
            cve_id TEXT,
            source TEXT,
            source_id TEXT,
            url TEXT,
            title TEXT,
            description TEXT,
            date_published TEXT,
            technique TEXT
        );
        """)
        with open(EXPLOITS_CSV, 'r', encoding='utf-8') as f:
            cursor.copy_expert(
                "COPY exploits (cve_id, source, source_id, url, title, description, date_published, technique) FROM STDIN WITH CSV HEADER",
                f
            )
        print("Imported exploits into PostgreSQL via COPY.")
    except Exception as e:
        print(f"PostgreSQL Error: {e}")
        sys.exit(1)
    finally:
        if conn is not None:
            cursor.close()
            conn.close()

def main():
    download_csv()
    total = process_exploits()
    import_to_postgres()
    print(f"\n=== Import Summary (Python) ===\nExploits attempted: {total}\n")

if __name__ == "__main__":
    main()
